'''
Created on 04.04.2013

@author: David Kiliani <mail@davidkiliani.de>
'''
# pylint: disable=C0103

import usb, array, struct, codecs

class MCCDevice(object):
    '''
    Base class for a MCC USB device.
    '''
    id_vendor = 0x09db
    id_product = None
    max_counts = None

    def __init__(self, serial_number=None):
        '''
        Constructor
        '''
        if self.id_product is None:
            raise ValueError('idProduct not defined')
        # find our device
        if serial_number is None:
            self.dev = usb.core.find(idVendor=self.id_vendor,
                                     idProduct=self.id_product)
        else:
            dev_list = usb.core.find(idVendor=self.id_vendor,
                idProduct=self.id_product, find_all=True)
            dev_list = [d for d in dev_list if usb.util.get_string(d,
                256, d.iSerialNumber) == serial_number]
            self.dev = dev_list[0] if dev_list else None
        # was it found?
        if self.dev is None:
            raise ValueError('Device not found')
        self.dev.set_configuration()
        self._intf = self.__get_interface()
        self._ep_in = self.__get_bulk_endpoint(usb.util.ENDPOINT_IN)
        self._ep_out = self.__get_bulk_endpoint(usb.util.ENDPOINT_OUT)
        self._bulk_packet_size = self._ep_in.wMaxPacketSize

    def send_message(self, message):
        '''
        Send a command message to the device via control transfer
        and return the device response.
        :param message: the command string to send
        '''
        try:
            assert self.dev.ctrl_transfer(usb.TYPE_VENDOR + usb.ENDPOINT_OUT,
                0x80, 0, 0, message.upper().encode('ascii')) == len(message)
        except AssertionError:
            raise IOError("Could not send message")
        except usb.core.USBError:
            raise IOError("Send failed, possibly wrong command?")
        ret = self.dev.ctrl_transfer(usb.TYPE_VENDOR + usb.ENDPOINT_IN,
                                     0x80, 0, 0, 64)
        return codecs.decode(ret, 'ascii').rstrip('\0')

    def read_scan_data(self, length, rate):
        '''
        Read the data generated by a AISCAN bulk transfer.
        :param length: the number of values to read
        :param rate: the sample rate of the AISCAN command in Hz
        '''
        timeout = int(self._bulk_packet_size * 1e3 / 2 / rate) + 10
        data = array.array('B')
        while (True):
            try:
                packet = self._ep_in.read(self._bulk_packet_size, timeout)
            except usb.core.USBError:
                pass
            data.extend(packet)
            if (len(packet) == 0) or (len(data) > length * 2):
                break
        return struct.unpack("=" + "H" * (len(data) / 2), data)[:length]

    def flush_input_data(self):
        while (True):
            try:
                packet = self._ep_in.read(self._bulk_packet_size, 20)
            except usb.core.USBError:
                break
            if len(packet) == 0:
                break

    def start_continuous_transfer(self, rate, mcc_buf, samps, delay):
        pass

    def stop_continuous_transfer(self):
        pass

    def get_calib_data(self, channel):
        slope = float(self.send_message("?AI{{{0}}}:SLOPE".format(channel)).
                      split('=')[1])
        offset = float(self.send_message("?AI{{{0}}}:OFFSET".format(channel)).
                       split('=')[1])
        return slope, offset

    def scale_and_calibrate_data(self, data, min_voltage, max_voltage,
                                 slope, offset):
        full_scale = max_voltage - min_voltage
        cal_data = data * float(slope) + offset
        return (cal_data / self.max_counts) * full_scale + min_voltage

    def __get_interface(self):
        '''Get the USB interface descriptor'''
        cfg = self.dev.get_active_configuration()
        intf_number = cfg[(0, 0)].bInterfaceNumber
        alternate_setting = usb.control.get_interface(self.dev, intf_number)
        return usb.util.find_descriptor(cfg, bInterfaceNumber=intf_number,
            bAlternateSetting=alternate_setting)

    def __get_bulk_endpoint(self, direction):
        '''
        Get the USB endpoint for bulk read or write
        :param direction: ENDPOINT_IN or ENDPOINT_OUT
        '''
        def ep_match(endp):
            '''Find an endpoint with descriptor = 5 and correct direction'''
            return (usb.util.endpoint_direction(endp.bEndpointAddress) ==
                direction) and (endp.bDescriptorType == 5)
        return usb.util.find_descriptor(self._intf, custom_match=ep_match)


class USB_7202(MCCDevice):
    '''USB-7202 card'''
    max_counts = 0xFFFF
    id_product = 0x00F2

class USB_7204(MCCDevice):
    '''USB-7204 card'''
    max_counts = 0x0FFF
    id_product = 0x00F0

class USB_2001_TC(MCCDevice):
    '''USB-2001-TC card'''
    max_counts = 1
    id_product = 0x00F9

class USB_1608FS_Plus(MCCDevice):
    '''USB-1608FS-Plus card'''
    max_counts = 0xFFFF
    id_product = 0x00EA

class USB_1608G(MCCDevice):
    '''USB-1608G card'''
    max_counts = 0xFFFF
    id_product = 0x0110

class USB_1608GX(USB_1608G):
    '''USB-1608GX card'''
    max_counts = 0xFFFF
    id_product = 0x0111

class USB_1608GX_2AO(USB_1608G):
    '''USB-1608GX-2AO card'''
    max_counts = 0xFFFF
    id_product = 0x0112

class USB_201(MCCDevice):
    '''USB-204 card'''
    max_counts = 0x0FFF
    id_product = 0x0113

class USB_204(MCCDevice):
    '''USB-204 card'''
    max_counts = 0x0FFF
    id_product = 0x0114
